<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: script.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: script.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Funci√≥n principal que inicia la ejecuci√≥n del algoritmo de b√∫squeda seleccionado.
 * 
 * Obtiene los valores de entrada del usuario, valida los datos, procesa la matriz del tablero,
 * ejecuta el algoritmo seleccionado (DFS, BFS, A* o Backtracking) y muestra los resultados con m√©tricas de rendimiento.
 * 
 * @function
 * @name iniciar
 * @returns {void}
 * 
 * @throws {Error} Si el algoritmo seleccionado no es reconocido
 * 
 * @example
 * // Ejemplo de uso:
 * // - El usuario ingresa el tablero en textarea#tableroInput
 * // - Selecciona coordenadas de salida en input#salidaInput
 * // - Elige un algoritmo en select#algoritmo
 * // - Llama a iniciar() para ejecutar la b√∫squeda
 * iniciar();
 * 
 * @description
 * Flujo de la funci√≥n:
 * 1. Obtiene y valida entradas del usuario
 * 2. Parsea y crea la matriz del tablero
 * 3. Valida restricciones de tama√±o (m√°ximo 12√ó12)
 * 4. Ejecuta el algoritmo seleccionado
 * 5. Calcula m√©tricas de rendimiento
 * 6. Muestra resultados y anima el camino encontrado
 * 
 * @requires DFS Funci√≥n de b√∫squeda en profundidad
 * @requires BFS Funci√≥n de b√∫squeda en anchura  
 * @requires Aestrella Funci√≥n de algoritmo A*
 * @requires Backtracking Funci√≥n de backtracking para soluci√≥n √≥ptima
 * @requires mostrarMatriz Funci√≥n para visualizar el tablero
 * @requires animarCamino Funci√≥n para animar la soluci√≥n encontrada
 */

// Variables globales para backtracking
let mejorCamino = null;        // Almacena la mejor soluci√≥n encontrada
let minMovimientos = Infinity; // Guarda el n√∫mero m√≠nimo de movimientos encontrado
let contadorEstadosBacktracking = 0; // Cuenta todos los estados explorados en backtracking

function iniciar() {
  // Obtener y validar entradas del usuario
  const entrada = document.getElementById("tableroInput").value.trim();
  const salida = document.getElementById("salidaInput").value.trim().split(",").map(Number);
  const algoritmo = document.getElementById("algoritmo").value;
  const acciones = document.getElementById("acciones");
  acciones.textContent = "";

  // Validaci√≥n de entrada b√°sica
  if (!entrada || salida.length !== 2) {
    alert("‚ö†Ô∏è Ingresa el tablero y las coordenadas de salida correctamente");
    return;
  }

  // Crear la matriz a partir del texto de entrada
  const matriz = entrada
    .split("\n")
    .map(fila => fila.trim())
    .filter(fila => fila.length > 0)
    .map(fila => fila.split(/\s+/).map(c => c.trim()));

  const [x, y] = salida;
  const filas = matriz.length;
  const columnas = matriz[0]?.length || 0;

  // Validaci√≥n de tama√±o del tablero 
  if (filas > 12 || columnas > 12) {
    alert(`‚ö†Ô∏è El tablero es demasiado grande (${filas}√ó${columnas}). El m√°ximo permitido es 12√ó12.`);
    return;
  }

  mostrarMatriz(matriz);

  // Variables para m√©tricas de rendimiento
  let inicio = performance.now();
  let fin = 0;
  let tiempo = 0;
  let estados = 0;
  let movimientos = 0;
  let camino = null;

  // Ejecutar el algoritmo seleccionado
  if (algoritmo === "DFS") {
    
    const visitados = new Set();
    camino = DFS(matriz, x, y, [], visitados);
    estados = visitados.size;
  } else if (algoritmo === "BFS") {
    
    const resultado = BFS(matriz, x, y);
    camino = resultado ? resultado.camino : null;
    estados = resultado ? resultado.estados : 0;
  } else if (algoritmo === "A*" || algoritmo === "Aestrella") {
   
    camino = Aestrella(matriz, x, y);
    estados = camino ? camino.length : 0;
  } else if (algoritmo === "Backtracking") {
   
    mejorCamino = null;           
    minMovimientos = Infinity;       
    contadorEstadosBacktracking = 0; 
    const visitados = new Set();  
    
    Backtracking(matriz, x, y, [], visitados);
    camino = mejorCamino;
    estados = contadorEstadosBacktracking; 
  } else {
    alert("‚ö†Ô∏è Algoritmo no reconocido");
    return;
  }

  // Calcula m√©tricas de rendimiento
  fin = performance.now();
  tiempo = (fin - inicio).toFixed(2);
  movimientos = camino ? camino.length - 1 : 0;

  // Mostrar resultados al usuario
  if (camino) {
    animarCamino(camino, tiempo, estados, movimientos);
  } else {
    acciones.textContent = `‚ùå No se encontr√≥ soluci√≥n con ${algoritmo}`;
  }

  // Log de m√©tricas en consola 
  console.log(`‚úÖ Algoritmo: ${algoritmo}`);
  console.log(`‚è± Tiempo: ${tiempo} ms`);
  console.log(`üìä Estados explorados: ${estados}`);
  console.log(`üöó Movimientos: ${movimientos}`);
}
  
//          node script.js  -,-,-,-,>,.,.;.,.,.,.,.,.,.;|,.,.,-,-,-,>;|,.,.,.,.,.,.;v,.,-,-,-,B,.;.,.,.,.,.,.,.;-,-,-,-,>,.,. .,.,|;-,B,v;.,.,.;.,-,>

//-------------------------------------------------------------------------------------------------------------------//


/**
 * Muestra visualmente la matriz del tablero en el contenedor HTML asignado.
 * Asigna clases CSS espec√≠ficas seg√∫n el tipo de celda para el estilo visual.
 * 
 * @function
 * @name mostrarMatriz
 * @param {string[][]} matriz - Matriz bidimensional que representa el tablero del juego
 * @returns {void}
 * 
 * @example
 * // Ejemplo de uso:
 * const miMatriz = [
 *   [".", ">", "-", "."],
 *   [".", "B", ".", "."],
 *   [".", "v", "|", "."]
 * ];
 * mostrarMatriz(miMatriz);
 * 
 * @description
 * Crea una tabla HTML donde cada celda tiene una clase CSS espec√≠fica:
 * - "carroB" para el carro principal (B)
 * - "carroH" para carros horizontales (>, -)
 * - "carroV" para carros verticales (v, |)
 * - "vacio" para celdas vac√≠as (.)
 */
function mostrarMatriz(matriz) {
  const contenedor = document.getElementById("tablero");
  contenedor.innerHTML = "";
  const tabla = document.createElement("table");

  matriz.forEach(fila => {
    const tr = document.createElement("tr");
    fila.forEach(celda => {
      const td = document.createElement("td");
      td.textContent = celda;
      td.className =
        celda === "B" ? "carroB" :
        celda === ">" || celda === "-" ? "carroH" :
        celda === "v" || celda === "|" ? "carroV" :
        "vacio";
      tr.appendChild(td);
    });
    tabla.appendChild(tr);
  });

  contenedor.appendChild(tabla);
}

/**
 * Verifica si la posici√≥n de salida (x,y) est√° alineada con el carro principal "B"
 * en los bordes del tablero para permitir la salida.
 * 
 * @function
 * @name encontrar
 * @param {string[][]} matriz - Matriz del tablero
 * @param {number} x - Coordenada X de la posici√≥n de salida
 * @param {number} y - Coordenada Y de la posici√≥n de salida
 * @returns {boolean} True si la salida est√° alineada con "B" en los bordes, false en caso contrario
 * 
 * @example
 * // Ejemplo de uso:
 * const matriz = [
 *   ["B", ">", ".", "."],
 *   [".", ".", ".", "."],
 *   [".", ".", ".", "."]
 * ];
 * encontrar(matriz, 0, 0); // Returns true (salida v√°lida)
 * encontrar(matriz, 1, 0); // Returns false (salida no alineada)
 * 
 * @description
 * La salida es v√°lida solo si:
 * - Las coordenadas est√°n dentro de los l√≠mites del tablero
 * - Existe un carro "B" en la matriz
 * - La posici√≥n (x,y) est√° en el borde y alineada con "B" (misma fila o columna)
 */
function encontrar(matriz, x, y) {
  if (x >= 0 &amp;&amp; x &lt; matriz.length &amp;&amp; y >= 0 &amp;&amp; y &lt; matriz[0].length) {
    for (let i = 0; i &lt; matriz.length; i++) {
      for (let j = 0; j &lt; matriz[x].length; j++) {
        if (matriz[i][j] === "B" &amp;&amp; (
          (x == 0 &amp;&amp; y == j) ||
          (x == matriz.length - 1 &amp;&amp; y == j) ||
          (y == 0 &amp;&amp; x == i) ||
          (y == matriz[0].length - 1 &amp;&amp; x == i)
        )) {
          console.log("biennnn")
          return true;
        }
      }
    }
    console.log("mal")
    return false
  }
}

/**
 * Mueve un carro horizontal hacia la derecha desde su cabeza (posici√≥n x,y).
 * Maneja tanto carros regulares (">") como el carro principal ("B").
 * 
 * @function
 * @name mover_derecha
 * @param {string[][]} matriz - Matriz del tablero
 * @param {number} x - Coordenada X de la cabeza del carro
 * @param {number} y - Coordenada Y de la cabeza del carro
 * @returns {string[][]} La matriz modificada despu√©s del movimiento
 * 
 * @example
 * // Ejemplo de uso:
 * const matriz = [
 *   [".", ">", "-", "."],
 *   [".", ".", ".", "."]
 * ];
 * mover_derecha(matriz, 0, 1); // Mueve el carro a la derecha
 * 
 * @description
 * L√≥gica del movimiento:
 * 1. Verifica que la cabeza sea ">" o "B"
 * 2. Verifica que haya espacio a la derecha
 * 3. Si la celda derecha est√° vac√≠a (".", mueve la cabeza
 * 4. Actualiza la cola del carro (convierte "-" a ".")
 * 5. Mantiene la integridad del carro horizontal
 */
function mover_derecha(matriz, x, y) {
  if (matriz[x][y] == ">") {
    if (y + 1 &lt; matriz[0].length) {
      if (matriz[x][y + 1] == ".") {
        let bandera = true
        matriz[x][y + 1] = ">"
        matriz[x][y] = "-"
        while (matriz[x][y] == "-") {
          if (y - 1 &lt; 0) {
            matriz[x][y] = "."
            bandera = false
            break
          }
          y -= 1
        }
        if (bandera)
          matriz[x][y + 1] = "."
        return matriz;
      }
      return matriz;
    }
    return matriz;
  } else if (matriz[x][y] == "B") {
    if (y + 1 &lt; matriz[0].length) {
      if (matriz[x][y + 1] == ".") {
        let bandera = true
        matriz[x][y + 1] = "B"
        matriz[x][y] = "-"
        while (matriz[x][y] == "-") {
          if (y - 1 &lt; 0) {
            matriz[x][y] = "."
            bandera = false
            break
          }
          y -= 1
        }
        if (bandera)
          matriz[x][y + 1] = "."
        return matriz;
      }
      return matriz;
    }
    return matriz;
  } else {
    return matriz;
  }
}

/**
 * Mueve un carro horizontal hacia la izquierda desde su cabeza (posici√≥n x,y).
 * Maneja tanto carros regulares (">") como el carro principal ("B").
 * 
 * @function
 * @name mover_izquierda
 * @param {string[][]} matriz - Matriz del tablero
 * @param {number} x - Coordenada X de la cabeza del carro
 * @param {number} y - Coordenada Y de la cabeza del carro
 * @returns {string[][]} La matriz modificada despu√©s del movimiento
 * 
 * @example
 * // Ejemplo de uso:
 * const matriz = [
 *   [".", ">", "-", "."],
 *   [".", ".", ".", "."]
 * ];
 * mover_izquierda(matriz, 0, 1); // Mueve el carro a la izquierda
 * 
 * @description
 * L√≥gica del movimiento:
 * 1. Verifica que la cabeza sea ">" o "B" y que haya espacio para moverse
 * 2. Busca la posici√≥n disponible a la izquierda
 * 3. Mueve la cabeza y actualiza la cola
 * 4. Mantiene la estructura del carro horizontal
 * 
 * @note
 * Esta funci√≥n tiene l√≥gica diferente a mover_derecha para manejar
 * el movimiento hacia la izquierda de manera eficiente
 */
function mover_izquierda(matriz, x, y) {

  if (matriz[x][y] == ">" &amp;&amp; y - 2 >= 0) {
    k = y
    y = y - 2
    while (matriz[x][y] == "-") {
      if (y - 1 &lt; 0) {
        return matriz;
      }
      y -= 1
    }

    if (matriz[x][y] == ".") {
      matriz[x][k] = "."
      matriz[x][k - 1] = ">"
      matriz[x][y] = "-"
    } else {
      return matriz;
    }
    return matriz
  } else if (matriz[x][y] == "B" &amp;&amp; y - 2 >= 0) {
    k = y
    y = y - 2
    while (matriz[x][y] == "-") {
      if (y - 1 &lt; 0) {
        return matriz;
      }
      y -= 1
    }

    if (matriz[x][y] == ".") {
      matriz[x][k] = "."
      matriz[x][k - 1] = "B"
      matriz[x][y] = "-"
    } else {
      return matriz;
    }
    return matriz
  } else {
    return matriz
  }
}
/**
 * Mueve un carro vertical hacia abajo desde su cabeza (posici√≥n x,y).
 * Los carros verticales tienen cabeza "v" y cuerpo "|".
 * 
 * @function
 * @name mover_abajo
 * @param {string[][]} matriz - Matriz del tablero
 * @param {number} x - Coordenada X de la cabeza del carro vertical
 * @param {number} y - Coordenada Y de la cabeza del carro vertical
 * @returns {string[][]} La matriz modificada despu√©s del movimiento, o la matriz original si no se puede mover
 * 
 * @example
 * // Ejemplo de uso:
 * const matriz = [
 *   [".", ".", ".", "."],
 *   [".", "v", ".", "."],
 *   [".", "|", ".", "."],
 *   [".", ".", ".", "."]
 * ];
 * mover_abajo(matriz, 1, 1); // Mueve el carro vertical hacia abajo
 * 
 * @description
 * L√≥gica del movimiento hacia abajo:
 * 1. Verifica que la celda (x,y) contenga "v" (cabeza de carro vertical)
 * 2. Verifica que haya espacio abajo (x+1 dentro de l√≠mites)
 * 3. Verifica que la celda abajo est√© vac√≠a (".")
 * 4. Mueve la cabeza a (x+1,y) y convierte la posici√≥n original a "|"
 * 5. Busca el final del carro hacia arriba y limpia la √∫ltima posici√≥n
 * 
 * @see mover_arriba Para el movimiento en direcci√≥n opuesta
 */
function mover_abajo(matriz, x, y) {
  if (matriz[x][y] == "v") {
    if (x + 1 &lt; matriz.length) {
      if (matriz[x + 1][y] == ".") {
        matriz[x + 1][y] = "v"
        matriz[x][y] = "|"
        x -= 1
        while (matriz[x][y] == "|") {
          x -= 1
          if (x &lt; 0) {
            break
          }
        }
        matriz[x + 1][y] = "."
        return matriz
      } else {
        return matriz;
      }
    } else {
      return matriz;
    }
  } else {
    return matriz;
  }
}

/**
 * Mueve un carro vertical hacia arriba desde su cabeza (posici√≥n x,y).
 * Los carros verticales tienen cabeza "v" y cuerpo "|".
 * 
 * @function
 * @name mover_arriba
 * @param {string[][]} matriz - Matriz del tablero
 * @param {number} x - Coordenada X de la cabeza del carro vertical
 * @param {number} y - Coordenada Y de la cabeza del carro vertical
 * @returns {string[][]} La matriz modificada despu√©s del movimiento, o la matriz original si no se puede mover
 * 
 * @example
 * // Ejemplo de uso:
 * const matriz = [
 *   [".", ".", ".", "."],
 *   [".", "v", ".", "."],
 *   [".", "|", ".", "."],
 *   [".", ".", ".", "."]
 * ];
 * mover_arriba(matriz, 1, 1); // Mueve el carro vertical hacia arriba
 * 
 * @description
 * L√≥gica del movimiento hacia arriba:
 * 1. Verifica que la celda (x,y) contenga "v" (cabeza de carro vertical)
 * 2. Busca el final del carro hacia arriba (posici√≥n disponible)
 * 3. Verifica que la posici√≥n encontrada est√© vac√≠a (".")
 * 4. Mueve todo el carro: nueva cabeza en (k-1,y), cuerpo en posiciones intermedias
 * 5. Limpia la posici√≥n anterior de la cabeza
 * 
 * @note
 * Esta funci√≥n usa una l√≥gica diferente a mover_abajo:
 * - Busca primero la posici√≥n disponible
 * - Mueve todo el carro en una operaci√≥n
 * - Es m√°s eficiente para movimiento hacia arriba
 * 
 * @see mover_abajo Para el movimiento en direcci√≥n opuesta
 */
function mover_arriba(matriz, x, y) {
  if (matriz[x][y] == "v") {
    let k = x;
    x = x - 1;
    
    // Buscar el final del carro hacia arriba
    while (x >= 0 &amp;&amp; matriz[x][y] == "|") {
      x -= 1;
    }
    
    if (x &lt; 0) {
      return matriz; // No se puede mover (l√≠mite del tablero)
    }
    
    if (matriz[x][y] == ".") {
      // Mover el carro completo
      matriz[x][y] = "|"; // Cuerpo del carro en nueva posici√≥n
      matriz[k][y] = "."; // Limpiar posici√≥n anterior de la cabeza
      matriz[k - 1][y] = "v"; // Nueva posici√≥n de la cabeza
      return matriz;
    } else {
      return matriz; // No se puede mover 
    }
  } else {
    return matriz; // No es un carro vertical
  }
}

/**
 * Busca y retorna todos los carros en la matriz, con el carro principal "B" siempre en primera posici√≥n.
 * Cada carro se representa como un array [s√≠mbolo, x, y] donde:
 * - s√≠mbolo: ">", "v" o "B" (tipo y direcci√≥n del carro)
 * - x: coordenada fila de la cabeza del carro
 * - y: coordenada columna de la cabeza del carro
 * 
 * @function
 * @name buscar_carros
 * @param {string[][]} matriz - Matriz del tablero a analizar
 * @param {Array|null} [carros=null] - Array opcional para acumular carros (uso interno en recursi√≥n)
 * @returns {Array} Array de carros ordenado con "B" siempre en primera posici√≥n
 * 
 * @example
 * // Ejemplo de uso:
 * const matriz = [
 *   [".", ">", ".", "."],
 *   ["B", "-", ".", "."],
 *   [".", "v", ".", "."]
 * ];
 * const carros = buscar_carros(matriz);
 * // Resultado: [["B", 1, 0], [">", 0, 1], ["v", 2, 1]]
 * 
 * @description
 * Proceso de la funci√≥n:
 * 1. Recorre toda la matriz buscando cabezas de carro (">", "v", "B")
 * 2. Almacena cada carro como [s√≠mbolo, fila, columna]
 * 3. Reordena el array para que "B" est√© siempre en la posici√≥n 0
 * 4. Retorna el array ordenado para procesamiento posterior
 */
function buscar_carros(matriz, carros = null) {
  if (carros == null) {
    carros = new Array();
  }
  for (let i = 0; i &lt; matriz.length; i++) {
    for (let j = 0; j &lt; matriz[0].length; j++) {
      if (matriz[i][j] == ">") {
        carros.push([">", i, j])
      }
      if (matriz[i][j] == "v") {
        carros.push(["v", i, j])
      }
      if (matriz[i][j] == "B") {
        carros.push(["B", i, j])
      }
    }
  }
  // Reordenar para que B vaya siempre primero
  let indiceB = carros.findIndex(sublista => sublista[0] === 'B');
  let temp = carros[0];
  carros[0] = carros[indiceB];
  carros[indiceB] = temp;
  return carros
}

/**
 * Crea una copia profunda de una matriz bidimensional.
 * Evita el problema de referencia en JavaScript donde las asignaciones normales
 * solo copian la referencia, no los valores.
 * 
 * @function
 * @name copiarMatriz
 * @param {string[][]} matriz - Matriz original a copiar
 * @returns {string[][]} Nueva matriz con los mismos valores pero independiente en memoria
 * 
 * @example
 * // Ejemplo de uso:
 * const original = [[".", ">"], ["B", "."]];
 * const copia = copiarMatriz(original);
 * copia[0][1] = "v"; // Esto NO afecta a la matriz original
 * 
 * @description
 * Esta funci√≥n es crucial para:
 * - Mantener el estado original durante la exploraci√≥n de algoritmos
 * - Evitar efectos secundarios en funciones que modifican matrices
 * - Permitir backtracking en algoritmos de b√∫squeda
 * 
 * @note
 * Sin esta funci√≥n, modificar una matriz "copiada" afectar√≠a a la original.
 */
function copiarMatriz(matriz) {
  return matriz.map(fila => [...fila]);
}

/**
 * Encuentra y retorna las coordenadas del carro principal B en la matriz.
 * 
 * @function
 * @name encontrarB
 * @param {string[][]} matriz - Matriz del tablero donde buscar
 * @returns {number[]|null} Array [fila, columna] con la posici√≥n de B, o null si no se encuentra
 * 
 * @example
 * // Ejemplo de uso:
 * const matriz = [
 *   [".", ".", "."],
 *   ["B", "-", "."],
 *   [".", ".", "."]
 * ];
 * const posB = encontrarB(matriz); // Retorna [1, 0]
 * 
 * @description
 * Funci√≥n utilitaria para:
 * - Localizar r√°pidamente la posici√≥n del carro principal
 * - Verificar si B existe en el tablero
 * - Inicializar algoritmos de b√∫squeda desde la posici√≥n correcta
 * 
 * @see buscar_carros Para obtener todos los carros incluyendo B
 */
function encontrarB(matriz) {
  for (let i = 0; i &lt; matriz.length; i++) {
    for (let j = 0; j &lt; matriz[0].length; j++) {
      if (matriz[i][j] === "B") {
        return [i, j];
      }
    }
  }
  return null; // Retorna null si no encuentra "B"
}

/**
 * Compara dos matrices consecutivas y genera una descripci√≥n legible del movimiento realizado.
 * Detecta autom√°ticamente la direcci√≥n y el carro que se movi√≥.
 * 
 * @function
 * @name describirMovimiento
 * @param {string[][]} anterior - Estado anterior del tablero
 * @param {string[][]} actual - Estado actual del tablero despu√©s del movimiento
 * @returns {string} Descripci√≥n textual del movimiento con emojis y coordenadas
 * 
 * @example
 * // Ejemplo de uso:
 * const anterior = [[".", ">", "."], [".", ".", "."]];
 * const actual = [[".", ".", ">"], [".", ".", "."]];
 * const descripcion = describirMovimiento(anterior, actual);
 * // Retorna: "üöó Carro > en posici√≥n (0,2) se movi√≥ hacia ‚û°Ô∏è derecha"
 * 
 * @description
 * Algoritmo de detecci√≥n:
 * 1. Encuentra las celdas que cambiaron entre ambas matrices
 * 2. Identifica la cabeza del carro antes y despu√©s del movimiento
 * 3. Determina la direcci√≥n comparando coordenadas
 * 4. Genera descripci√≥n con emojis para mejor legibilidad
 * 
 * @returns {string} Descripci√≥n en formato: "üöó Carro {s√≠mbolo} en posici√≥n ({x},{y}) se movi√≥ hacia {direcci√≥n}"
 * 
 * @note
 * Las direcciones detectadas son:
 * - derecha (misma fila, columna aumenta)
 * - izquierda (misma fila, columna disminuye)  
 * - abajo (misma columna, fila aumenta)
 * - arriba (misma columna, fila disminuye)
 */
function describirMovimiento(anterior, actual) {
  let antes = null, despues = null, simbolo = null;

  for (let i = 0; i &lt; anterior.length; i++) {
    for (let j = 0; j &lt; anterior[0].length; j++) {
      if (anterior[i][j] !== actual[i][j]) {
        // Guarda las posiciones que cambiaron
        if (anterior[i][j] !== "." &amp;&amp; anterior[i][j] !== "-" &amp;&amp; anterior[i][j] !== "|") {
          antes = [i, j, anterior[i][j]];
        }
        if (actual[i][j] !== "." &amp;&amp; actual[i][j] !== "-" &amp;&amp; actual[i][j] !== "|") {
          despues = [i, j, actual[i][j]];
        }
      }
    }
  }

  if (!antes || !despues) return "Movimiento desconocido";

  simbolo = despues[2];
  const [i1, j1] = antes;
  const [i2, j2] = despues;

  // Determinar direcci√≥n con texto y coordenadas
  let direccion = "";
  if (i2 === i1 &amp;&amp; j2 > j1) direccion = "‚û°Ô∏è derecha";
  else if (i2 === i1 &amp;&amp; j2 &lt; j1) direccion = "‚¨ÖÔ∏è izquierda";
  else if (j2 === j1 &amp;&amp; i2 > i1) direccion = "‚¨áÔ∏è abajo";
  else if (j2 === j1 &amp;&amp; i2 &lt; i1) direccion = "‚¨ÜÔ∏è arriba";
  else direccion = "a otra posici√≥n";

  return `üöó Carro ${simbolo} en posici√≥n (${i2},${j2}) se movi√≥ hacia ${direccion}`;
}




 /**
 * Implementa el algoritmo de B√∫squeda en Profundidad (DFS) para resolver el puzzle de carros.
 * Explora recursivamente todos los movimientos posibles hasta encontrar una soluci√≥n o agotar las posibilidades.
 * 
 * @function
 * @name DFS
 * @param {string[][]} matriz - Estado actual del tablero
 * @param {number} x - Coordenada X de la posici√≥n de salida objetivo
 * @param {number} y - Coordenada Y de la posici√≥n de salida objetivo
 * @param {Array} [camino=[]] - Array que almacena la secuencia de estados del tablero hacia la soluci√≥n
 * @param {Set} [visitados=new Set()] - Conjunto de estados ya visitados para evitar ciclos
 * @returns {Array|null} Array de matrices representando el camino soluci√≥n, o null si no se encuentra
 * 
 * @example
 * // Ejemplo de uso:
 * const matrizInicial = [
 *   [".", "B", "-", "."],
 *   [".", ".", ".", "."],
 *   [".", "v", ".", "."]
 * ];
 * const solucion = DFS(matrizInicial, 0, 3, [], new Set());
 * if (solucion) {
 *   console.log("Soluci√≥n encontrada con", solucion.length, "movimientos");
 * }
 * 
 * @description
 * Algoritmo DFS implementado:
 * 1. **Evitar ciclos**: Usa hashing de matrices para detectar estados repetidos
 * 2. **Condici√≥n de t√©rmino**: Verifica si el carro "B" lleg√≥ a la salida (x,y)
 * 3. **Exploraci√≥n recursiva**: Para cada carro, prueba todos los movimientos posibles
 * 4. **Backtracking**: Si un camino no lleva a soluci√≥n, retrocede y prueba alternativas
 * 
 * @throws {Error} Puede producir error de pila si el √°rbol de b√∫squeda es muy profundo
 * 
 * @note
 * Caracter√≠sticas de esta implementaci√≥n:
 * - Prioriza el carro B (siempre primero en la lista de carros)
 * - Usa copias profundas para evitar efectos secundarios
 * - Maneja tanto carros horizontales (B, >) como verticales (v)
 * - El par√°metro `[...camino]` crea copias para ramas independientes
 * 
 * @see buscar_carros Para obtener la lista de carros ordenada
 * @see copiarMatriz Para crear copias independientes del estado
 * @see mover_izquierda, mover_derecha, mover_arriba, mover_abajo Para los operadores de movimiento
 * 
 * @complexity
 * - Tiempo: O(b^d) donde b es el factor de ramificaci√≥n y d la profundidad
 * - Espacio: O(d) para la pila de recursi√≥n (sin contar visitados)
 * 
 * @warning
 * Puede sufrir de "depth limit" en puzzles complejos debido a la recursi√≥n
 */
function DFS(matriz, x, y, camino = [], visitados = new Set()) {
  // Evitar bucles infinitos detecta estados repetidos
  const hash = JSON.stringify(matriz);
  if (visitados.has(hash)) {
    return null; 
  }

  visitados.add(hash);

  // Verifica si el carro B llego a la salida
  const carros = buscar_carros(matriz);
  if (carros[0][1] == x &amp;&amp; carros[0][2] == y) {
    camino.push(copiarMatriz(matriz)); // guardar el ultimo estado tambien
    return camino; 
  }

  camino.push(copiarMatriz(matriz));

  // Explorar todos los movimientos posibles para cada carro
  for (carro of carros) {
    if (carro[0] == "B" || carro[0] == ">") {
      // Carros horizontales probar izquierda y derecha
      const matrizIzq = mover_izquierda(copiarMatriz(matriz), carro[1], carro[2]);
      const matrizDer = mover_derecha(copiarMatriz(matriz), carro[1], carro[2]);
      
      if (JSON.stringify(matrizIzq) !== JSON.stringify(matriz)) {
        const res = DFS(matrizIzq, x, y, [...camino], visitados); //copiar el camino
        if (res)
           return res;
      }
      if (JSON.stringify(matrizDer) !== JSON.stringify(matriz)) {
        const res = DFS(matrizDer, x, y, [...camino], visitados);
        if (res) 
          return res;
      }
    } 
    else {
      // Carros verticales probar arriba y abajo
      const matrizArr = mover_arriba(copiarMatriz(matriz), carro[1], carro[2]);
      const matrizAba = mover_abajo(copiarMatriz(matriz), carro[1], carro[2]);
      
      if (JSON.stringify(matrizArr) !== JSON.stringify(matriz)) {
        const res = DFS(matrizArr, x, y, [...camino], visitados);
        if (res) 
          return res;
      }

      if (JSON.stringify(matrizAba) !== JSON.stringify(matriz)) {
        const res = DFS(matrizAba, x, y, [...camino], visitados);
        if (res) 
          return res;
      }
    }
  }
  return null;
}






/**
 * Convierte una matriz en un string hash √∫nico para comparaci√≥n de estados.
 * Utilizado para detectar estados duplicados en los algoritmos de b√∫squeda.
 * 
 * @function
 * @name matrizAHash
 * @param {string[][]} m - Matriz a convertir en hash
 * @returns {string} Representaci√≥n en string de la matriz
 * 
 * @example
 * // Ejemplo de uso:
 * const matriz = [[".", "B"], [">", "."]];
 * const hash = matrizAHash(matriz); // Retorna "[[".","B"],[">","."]]"
 * 
 * @description
 * Funci√≥n utilitaria para:
 * - Comparaci√≥n eficiente de estados del tablero
 * - Detecci√≥n de estados repetidos en b√∫squedas
 * - Uso en conjuntos (Set) para verificaci√≥n de visitados
 * 
 * @see Aestrella Para el uso principal en el algoritmo A*
 */
function matrizAHash(m) {
  return JSON.stringify(m);
}

/**
 * Implementa el algoritmo A* (A Estrella) para resolver el puzzle de carros.
 * Utiliza una funci√≥n heur√≠stica para guiar la b√∫squeda hacia la soluci√≥n √≥ptima.
 * 
 * @function
 * @name Aestrella
 * @param {string[][]} matriz - Estado inicial del tablero
 * @param {number} x - Coordenada X de la posici√≥n de salida objetivo
 * @param {number} y - Coordenada Y de la posici√≥n de salida objetivo
 * @returns {Array|null} Array de matrices representando el camino soluci√≥n √≥ptimo, o null si no se encuentra
 * 
 * @example
 * // Ejemplo de uso:
 * const matrizInicial = [
 *   [".", "B", "-", "."],
 *   [".", ".", ".", "."],
 *   [".", "v", ".", "."]
 * ];
 * const solucion = Aestrella(matrizInicial, 0, 3);
 * if (solucion) {
 *   console.log("Soluci√≥n √≥ptima encontrada con", solucion.length, "movimientos");
 * }
 * 
 * @description
 * Algoritmo A* implementado:
 * 1. **Lista abierta**: Estados por explorar, ordenados por f = g + h
 * 2. **Lista cerrada**: Estados ya explorados para evitar redundancia
 * 3. **Funci√≥n heur√≠stica**: Estima el costo desde el estado actual hasta la meta
 * 4. **Expansi√≥n**: Genera todos los movimientos v√°lidos desde el estado actual
 * 
 * @description
 * Estructura de elementos en listaAbierta:
 * - [0]: Matriz del estado
 * - [1]: f = g + h (costo total)
 * - [2]: g (costo real desde el inicio)
 * - [3]: h (valor heur√≠stico)
 * - [4]: camino (secuencia de matrices hasta este estado)
 * 
 * @description
 * Heur√≠stica implementada:
 * - Calcula la distancia horizontal desde "B" hasta la columna objetivo Y
 * - Penaliza celdas ocupadas (heur√≠stica += 2) vs celdas vac√≠as (heur√≠stica += 1)
 * - Asume que el camino m√°s directo es moverse horizontalmente hacia la salida
 * 
 * @note
 * Caracter√≠sticas de esta implementaci√≥n:
 * - Usa b√∫squeda del mejor primero basada en f = g + h
 * - Mantiene el camino completo para retornar la soluci√≥n
 * - Considera tanto carros horizontales como verticales
 * - La heur√≠stica es admisible pero podr√≠a mejorarse
 * 
 * @complexity
 * - Tiempo: O(b^d) en el peor caso, pero guiada por heur√≠stica
 * - Espacio: O(b^d) para almacenar estados en listas
 * 
 * @see matrizAHash Para la detecci√≥n de estados duplicados
 * @see buscar_carros Para obtener carros del tablero
 * @see encontrarB Para localizar el carro principal
 */
function Aestrella(matriz, x, y) {
  const listaAbierta = [];
  const listaCerrada = new Set();

  // Inicializar con estado inicial [matriz, f, g, h, camino]
  listaAbierta.push([copiarMatriz(matriz), 0, 0, 0, [copiarMatriz(matriz)]]);

  while (listaAbierta.length != 0) {
    // Encontrar el nodo con menor f en la lista abierta
    let mejorF = Infinity;
    let pos;
    let g = 0;
    let indiceMejor = 0;
    let caminoActual = [];

    for (let i = 0; i &lt; listaAbierta.length; i++) {
      if (listaAbierta[i][1] &lt; mejorF) {
        mejorF = listaAbierta[i][1];
        pos = copiarMatriz(listaAbierta[i][0]);
        g = listaAbierta[i][2];
        indiceMejor = i;
        caminoActual = listaAbierta[i][4]; // recupera el camino que llev√≥ hasta ah√≠
      }
    }

    // Mover nodo actual de abierta a cerrada
    listaCerrada.add(JSON.stringify(listaAbierta[indiceMejor][0]));
    listaAbierta.splice(indiceMejor, 1);

    const carros = buscar_carros(pos);

    // Verificar condici√≥n de soluci√≥n
    const [l, p] = encontrarB(pos);
    if (l == x &amp;&amp; p == y) {
      return caminoActual; // Devolver camino completo hacia la soluci√≥n
    }

    // Expandir todos los movimientos posibles
    for (carro of carros) {
      if (carro[0] == "B" || carro[0] == ">") {
        // Carros horizontales
        const matrizIzq = mover_izquierda(copiarMatriz(pos), carro[1], carro[2]);
        const matrizDer = mover_derecha(copiarMatriz(pos), carro[1], carro[2]);

        // ================= MOVIMIENTO IZQUIERDA =================
        if (JSON.stringify(matrizIzq) !== JSON.stringify(pos)) {
          if (!listaCerrada.has(JSON.stringify(matrizIzq))) {
            listaCerrada.add(JSON.stringify(matrizIzq)); 
            let heuristica = 1;
            let [i, j] = encontrarB(matrizIzq);
            // Calcular heur√≠stica distancia horizontal hasta Y
            while (j &lt; y) {
              if (matrizIzq[i][j] == ".") {
                heuristica += 1;
              } else {
                heuristica += 2; // Penalizar celdas ocupadas
              }
              j += 1;
            }
            let gx = g + 1; // Costo real incrementado
            let f = gx + heuristica;
            listaAbierta.push([
              copiarMatriz(matrizIzq),
              f,
              gx,
              heuristica,
              [...caminoActual, copiarMatriz(matrizIzq)] // Extender camino
            ]);
          }
        }

        // ================= MOVIMIENTO DERECHA =================
        if (JSON.stringify(matrizDer) !== JSON.stringify(pos)) {
          if (!listaCerrada.has(JSON.stringify(matrizDer))) {
            listaCerrada.add(JSON.stringify(matrizDer)); 
            let heuristica = 1;
            let [i, j] = encontrarB(matrizDer);
            while (j &lt; y) {
              if (matrizDer[i][j] == ".") {
                heuristica += 1;
              } else {
                heuristica += 2;
              }
              j += 1;
            }
            let gx = g + 1;
            let f = gx + heuristica;
            listaAbierta.push([
              copiarMatriz(matrizDer),
              f,
              gx,
              heuristica,
              [...caminoActual, copiarMatriz(matrizDer)]
            ]);
          }
        }
      } else {
        // Carros verticales
        const matrizArr = mover_arriba(copiarMatriz(pos), carro[1], carro[2]);
        const matrizAba = mover_abajo(copiarMatriz(pos), carro[1], carro[2]);

        // ================= MOVIMIENTO ARRIBA =================
        if (JSON.stringify(matrizArr) !== JSON.stringify(pos)) {
          if (!listaCerrada.has(JSON.stringify(matrizArr))) {
            listaCerrada.add(JSON.stringify(matrizArr)); 
            let heuristica = 1;
            let [i, j] = encontrarB(matrizArr);
            while (j &lt; y) {
              if (matrizArr[i][j] == ".") {
                heuristica += 1;
              } else {
                heuristica += 2;
              }
              j += 1;
            }
            let gx = g + 1;
            let f = gx + heuristica;
            listaAbierta.push([
              copiarMatriz(matrizArr),
              f,
              gx,
              heuristica,
              [...caminoActual, copiarMatriz(matrizArr)]
            ]);
          }
        }

        // ================= MOVIMIENTO ABAJO =================
        if (JSON.stringify(matrizAba) !== JSON.stringify(pos)) {
          if (!listaCerrada.has(JSON.stringify(matrizAba))) {
            listaCerrada.add(JSON.stringify(matrizAba)); 
            let heuristica = 1;
            let [i, j] = encontrarB(matrizAba);
            while (j &lt; y) {
              if (matrizAba[i][j] == ".") {
                heuristica += 1;
              } else {
                heuristica += 2;
              }
              j += 1;
            }
            let gx = g + 1;
            let f = gx + heuristica;
            listaAbierta.push([
              copiarMatriz(matrizAba),
              f,
              gx,
              heuristica,
              [...caminoActual, copiarMatriz(matrizAba)]
            ]);
          }
        }
      }
    }
  }
  return null; // No se encontr√≥ camino hacia la soluci√≥n
}
/**
 * Implementa el algoritmo de B√∫squeda en Anchura (BFS) para resolver el puzzle de carros.
 * Explora todos los estados nivel por nivel, garantizando encontrar la soluci√≥n m√°s corta si existe.
 * 
 * @function
 * @name BFS
 * @param {string[][]} matriz - Estado inicial del tablero
 * @param {number} x - Coordenada X de la posici√≥n de salida objetivo
 * @param {number} y - Coordenada Y de la posici√≥n de salida objetivo
 * @returns {Object|null} Objeto con la soluci√≥n o null si no se encuentra
 * @returns {Array} return.camino - Secuencia de matrices del camino soluci√≥n
 * @returns {number} return.estados - Total de estados explorados
 * @returns {number} return.profundidad - N√∫mero de movimientos de la soluci√≥n
 * 
 * @example
 * // Ejemplo de uso:
 * const matrizInicial = [
 *   [".", "B", "-", "."],
 *   [".", ".", ".", "."]
 * ];
 * const resultado = BFS(matrizInicial, 0, 3);
 * if (resultado) {
 *   console.log("Soluci√≥n en", resultado.profundidad, "movimientos");
 *   console.log("Estados explorados:", resultado.estados);
 * }
 * 
 * @description
 * Caracter√≠sticas del algoritmo BFS implementado:
 * - **Garant√≠a de optimalidad**: Encuentra el camino m√°s corto (menor n√∫mero de movimientos)
 * - **Exploraci√≥n por niveles**: Expande todos los estados de profundidad n antes de pasar a n+1
 * - **Control de memoria**: L√≠mite de 50,000 estados para evitar desbordamiento
 * - **M√©tricas detalladas**: Registra niveles explorados y estad√≠sticas de b√∫squeda
 * 
 * @description
 * Estructura del estado en la cola:
 * - matriz: Estado actual del tablero
 * - camino: Secuencia completa de estados desde el inicio
 * - profundidad: N√∫mero de movimientos realizados hasta este estado
 * 
 * @complexity
 * - Tiempo: O(b^d) donde b es el factor de ramificaci√≥n y d la profundidad de la soluci√≥n
 * - Espacio: O(b^d) para almacenar todos los estados en memoria
 * 
 * @see generarTodosLosMovimientos Para la generaci√≥n de estados sucesores
 * @see matrizAHash Para detecci√≥n de estados duplicados
 */
function BFS(matriz, x, y) {
  const cola = [];
  const visitados = new Set();
  
  // Estado inicial con camino y profundidad
  const estadoInicial = {
    matriz: copiarMatriz(matriz),
    camino: [copiarMatriz(matriz)],
    profundidad: 0
  };
  
  cola.push(estadoInicial);
  visitados.add(matrizAHash(matriz));

  let nivelesExplorados = 0;
  let estadosPorNivel = [1]; // Contador de estados por nivel

  while (cola.length > 0) {
    const actual = cola.shift(); // FIFO
    const matrizActual = actual.matriz;
    const caminoActual = actual.camino;
    const profundidadActual = actual.profundidad;

    // Verificar si encontramos la soluci√≥n
    const [posBx, posBy] = encontrarB(matrizActual);
    if (posBx === x &amp;&amp; posBy === y) {
      console.log(`‚úÖ BFS encontr√≥ soluci√≥n en profundidad ${profundidadActual}`);
      console.log(`üìä Niveles explorados: ${nivelesExplorados}`);
      return {
        camino: caminoActual,
        estados: visitados.size,
        profundidad: profundidadActual
      };
    }

    // Generar y explorar todos los movimientos posibles
    const movimientosPosibles = generarTodosLosMovimientos(matrizActual);
    
    for (const movimiento of movimientosPosibles) {
      const hash = matrizAHash(movimiento);
      
      if (!visitados.has(hash)) {
        visitados.add(hash);
        
        // Agregar nuevo estado a la cola
        cola.push({
          matriz: movimiento,
          camino: [...caminoActual, copiarMatriz(movimiento)],
          profundidad: profundidadActual + 1
        });
      }
    }

    // Control de niveles explorados m√©tricas
    if (estadosPorNivel[nivelesExplorados] === 0) {
      nivelesExplorados++;
      estadosPorNivel[nivelesExplorados] = cola.length;
    } else {
      estadosPorNivel[nivelesExplorados]--;
    }

    // L√≠mite para evitar desbordamiento de memoria
    if (visitados.size > 50000) {
      console.log("BFS: L√≠mite de estados alcanzado");
      break;
    }
  }
  
  console.log("‚ùå BFS no encontr√≥ soluci√≥n");
  return null;
}

/**
 * Genera todos los movimientos v√°lidos posibles desde un estado dado del tablero.
 * Considera todos los carros y todas las direcciones posibles para cada uno.
 * 
 * @function
 * @name generarTodosLosMovimientos
 * @param {string[][]} matriz - Estado actual del tablero
 * @returns {string[][][]} Array de matrices representando todos los estados sucesores v√°lidos
 * 
 * @example
 * // Ejemplo de uso:
 * const matriz = [
 *   [".", ">", "."],
 *   ["B", "-", "."]
 * ];
 * const movimientos = generarTodosLosMovimientos(matriz);
 * // Retorna array con todas las matrices resultantes de movimientos v√°lidos
 * 
 * @description
 * Proceso de generaci√≥n de movimientos:
 * 1. Obtiene todos los carros del tablero usando buscar_carros()
 * 2. Para cada carro, prueba todas las direcciones posibles:
 *    - Carros horizontales (B, >): izquierda y derecha
 *    - Carros verticales (v): arriba y abajo
 * 3. Filtra solo los movimientos que realmente cambian el tablero
 * 
 * @see buscar_carros Para identificar los carros en el tablero
 * @see mover_derecha, mover_izquierda, mover_arriba, mover_abajo Para los operadores de movimiento
 */
function generarTodosLosMovimientos(matriz) {
  const movimientos = [];
  const carros = buscar_carros(matriz);

  for (const carro of carros) {
    const [tipo, x, y] = carro;
    
    if (tipo === "B" || tipo === ">") {
      // Carros horizontales: probar derecha e izquierda
      const matrizDer = mover_derecha(copiarMatriz(matriz), x, y);
      if (JSON.stringify(matrizDer) !== JSON.stringify(matriz)) {
        movimientos.push(matrizDer);
      }

      const matrizIzq = mover_izquierda(copiarMatriz(matriz), x, y);
      if (JSON.stringify(matrizIzq) !== JSON.stringify(matriz)) {
        movimientos.push(matrizIzq);
      }
    } 
    else if (tipo === "v") {
      // Carros verticales: probar arriba y abajo
      const matrizArr = mover_arriba(copiarMatriz(matriz), x, y);
      if (JSON.stringify(matrizArr) !== JSON.stringify(matriz)) {
        movimientos.push(matrizArr);
      }

      const matrizAba = mover_abajo(copiarMatriz(matriz), x, y);
      if (JSON.stringify(matrizAba) !== JSON.stringify(matriz)) {
        movimientos.push(matrizAba);
      }
    }
  }
  
  return movimientos;
}

/**
 * Funci√≥n de backtracking para resolver el problema del traffic jam.
 * Explora sistem√°ticamente todos los movimientos posibles hasta encontrar la soluci√≥n √≥ptima.
 * 
 * @function
 * @name Backtracking
 * @param {Array.&lt;Array.&lt;string>>} matriz - Matriz representando el estado actual del tablero
 * @param {number} x - Coordenada X (fila) de la salida objetivo
 * @param {number} y - Coordenada Y (columna) de la salida objetivo  
 * @param {Array.&lt;Array.&lt;Array.&lt;string>>>} [caminoActual=[]] - Camino de estados visitados hasta el momento
 * @param {Set} [visitados=new Set()] - Conjunto de estados ya explorados (hashed)
 * @returns {void}
 * 
 * @example
 * // Uso b√°sico:
 * Backtracking(matrizInicial, 2, 5, [], new Set());
 * 
 * @description
 * Esta funci√≥n implementa un algoritmo de backtracking que:
 * 1. Cuenta cada estado explorado globalmente
 * 2. Evita ciclos mediante un conjunto de estados visitados
 * 3. Poda ramas que exceden la mejor soluci√≥n encontrada
 * 4. Encuentra la soluci√≥n con m√≠nimo n√∫mero de movimientos
 * 5. Limita la profundidad m√°xima para evitar stack overflow
 * 
 * @see encontrarB
 * @see buscar_carros
 * @see mover_derecha
 * @see mover_izquierda  
 * @see mover_abajo
 * @see mover_arriba
 * @see copiarMatriz
 * 
 */
function Backtracking(matriz, x, y, caminoActual = [], visitados = new Set()) {
    // Contar este estado en el contador global
    contadorEstadosBacktracking++; 
    
    // evitar ciclos
    let hash = JSON.stringify(matriz);
    if (visitados.has(hash)) {
        return;
    }
    visitados.add(hash);
    
    //si ya hay una soluci√≥n mejor para
    if (caminoActual.length >= minMovimientos) {
        return;
    }
    
    // Condici√≥n si el carro B lleg√≥ a la salida
    let carroB = encontrarB(matriz);
    if (carroB[0] == x &amp;&amp; carroB[1] == y) {
        let caminoFinal = [...caminoActual, copiarMatriz(matriz)];
        let numMovimientos = caminoFinal.length - 1;
        
        // Actualizar la mejor soluci√≥n encontrada
        if (numMovimientos &lt; minMovimientos) {
            minMovimientos = numMovimientos;
            mejorCamino = caminoFinal;
            console.log("¬°Encontr√© una soluci√≥n con " + numMovimientos + " movimientos!");
        }
        return;
    }
    
    // L√≠mite de profundidad para evitar overflow
    if (caminoActual.length > 100) {
        return;
    }
    
    // Agregar este estado al camino actual
    caminoActual.push(copiarMatriz(matriz));
    
    // Probar mover todos los carros en todas direcciones posibles
    let carros = buscar_carros(matriz);
    
    for (let i = 0; i &lt; carros.length; i++) {
        let carro = carros[i];
        let tipo = carro[0];
        let fila = carro[1];
        let columna = carro[2];
        
        // Movimientos para carros horizontales 
        if (tipo == "B" || tipo == ">") {
            // Intentar mover a la derecha
            let matrizDer = mover_derecha(copiarMatriz(matriz), fila, columna);
            if (JSON.stringify(matrizDer) != JSON.stringify(matriz)) {
                Backtracking(matrizDer, x, y, [...caminoActual], new Set(visitados));
            }
            
            // Intentar mover a la izquierda  
            let matrizIzq = mover_izquierda(copiarMatriz(matriz), fila, columna);
            if (JSON.stringify(matrizIzq) != JSON.stringify(matriz)) {
                Backtracking(matrizIzq, x, y, [...caminoActual], new Set(visitados));
            }
        }
        
        // Movimientos para carros verticales 
        if (tipo == "v") {
            // Intentar mover abajo
            let matrizAbajo = mover_abajo(copiarMatriz(matriz), fila, columna);
            if (JSON.stringify(matrizAbajo) != JSON.stringify(matriz)) {
                Backtracking(matrizAbajo, x, y, [...caminoActual], new Set(visitados));
            }
            
            // Intentar mover arriba
            let matrizArriba = mover_arriba(copiarMatriz(matriz), fila, columna);
            if (JSON.stringify(matrizArriba) != JSON.stringify(matriz)) {
                Backtracking(matrizArriba, x, y, [...caminoActual], new Set(visitados));
            }
        }
    }
    
    
    caminoActual.pop();
}

/**
 * Anima visualmente la secuencia de pasos de la soluci√≥n encontrada.
 * Muestra cada estado del camino con una descripci√≥n textual de los movimientos.
 * 
 * @function
 * @name animarCamino
 * @param {string[][][]} camino - Array de matrices representando la secuencia soluci√≥n
 * @param {number} tiempo - Tiempo total de ejecuci√≥n del algoritmo en milisegundos
 * @param {number} estados - N√∫mero total de estados explorados
 * @param {number} movimientos - N√∫mero de movimientos de la soluci√≥n
 * @returns {void}
 * 
 * @example
 * // Ejemplo de uso:
 * const camino = [matriz1, matriz2, matriz3];
 * animarCamino(camino, 1500, 250, 3);
 * 
 * @description
 * Proceso de animaci√≥n:
 * 1. Muestra cada estado del camino con intervalo de 400ms
 * 2. Describe cada movimiento usando describirMovimiento()
 * 3. Actualiza la interfaz de usuario con m√©tricas finales
 * 4. Proporciona feedback visual del progreso
 * 
 * @see describirMovimiento Para generar descripciones legibles de cada movimiento
 * @see mostrarMatriz Para la visualizaci√≥n del tablero en cada paso
 */
function animarCamino(camino, tiempo, estados, movimientos) {
  let i = 0;
  const acciones = document.getElementById("acciones");
  acciones.textContent = "üîÑ Resolviendo...\n";

  function paso() {
    if (i &lt; camino.length) {
      mostrarMatriz(camino[i]);

      if (i > 0) {
        // Detectar y mostrar acci√≥n entre paso anterior y actual
        const textoAccion = describirMovimiento(camino[i - 1], camino[i]);
        acciones.textContent += `\n${i}. ${textoAccion}`;
      } else {
        acciones.textContent += `\nInicio del recorrido...`;
      }

      i++;
      setTimeout(paso, 400); // Velocidad de animaci√≥n
    } else {
      // Mostrar resumen final
      acciones.textContent +=
        `\n\n‚úÖ ¬°Carro objetivo lleg√≥ a la salida!\n\n` +
        `‚è± Tiempo: ${tiempo} ms\n` +
        `üìä Estados explorados: ${estados}\n` +
        `üöó Movimientos: ${movimientos}`;
    }
  }

  paso();
}



/**
 * Event listener para el bot√≥n de resolver.
 * Inicia el proceso de resoluci√≥n cuando se hace clic en el bot√≥n.
 * 
 * @event
 * @listens document#click:id=resolverBtn
 * @see iniciar Funci√≥n principal de resoluci√≥n
 */
document.getElementById("resolverBtn").addEventListener("click", iniciar);



//          node script.js  .,.,|;-,B,v;.,.,.;.,-,>
// original -,-,-,-,>,.,.;.,.,.,.,.,.,.;|,.,.,-,-,-,>;|,.,.,.,.,.,.;v,.,-,-,-,B,.;.,.,.,.,.,.,.;-,-,-,-,>,.,.

//-------------------------------------------------------------------------------------------------------------------//

// [ CARROS:
//   [ 'B', 4, 5 ],
//   [ '>', 2, 6 ],
//   [ 'v', 4, 0 ],
//   [ '>', 0, 4 ],
//   [ '>', 6, 4 ]
// ]
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#Aestrella">Aestrella</a></li><li><a href="global.html#BFS">BFS</a></li><li><a href="global.html#Backtracking">Backtracking</a></li><li><a href="global.html#DFS">DFS</a></li><li><a href="global.html#animarCamino">animarCamino</a></li><li><a href="global.html#buscar_carros">buscar_carros</a></li><li><a href="global.html#copiarMatriz">copiarMatriz</a></li><li><a href="global.html#describirMovimiento">describirMovimiento</a></li><li><a href="global.html#encontrar">encontrar</a></li><li><a href="global.html#encontrarB">encontrarB</a></li><li><a href="global.html#generarTodosLosMovimientos">generarTodosLosMovimientos</a></li><li><a href="global.html#iniciar">iniciar</a></li><li><a href="global.html#matrizAHash">matrizAHash</a></li><li><a href="global.html#mostrarMatriz">mostrarMatriz</a></li><li><a href="global.html#mover_abajo">mover_abajo</a></li><li><a href="global.html#mover_arriba">mover_arriba</a></li><li><a href="global.html#mover_derecha">mover_derecha</a></li><li><a href="global.html#mover_izquierda">mover_izquierda</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Thu Oct 23 2025 17:48:08 GMT-0600 (hora est√°ndar central)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
